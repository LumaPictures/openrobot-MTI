

#ifndef WIN32
#include <sys/ioctl.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <time.h>
#include <sys/time.h>

#include "../MTI/MTI.h"
#include "../MTI/MTComm.h"





/*!
  @brief : main
*/
int testMTI(int argc, char *argv[]) 
{ 
  CMTComm mtcomm;

  int outputMode;
  int portNumber;
  char deviceName[15];
  int outputSettings;
  unsigned short numDevices;


  unsigned char data[MAXMSGLEN];
  short datalen;
  float fdata[18] = {0};
  unsigned short samplecounter;

  // convert float to string to log
  char msg[250];
  char msgHorodatage[100];

  int  ch;
  
  static char *logFile=NULL;
  int verbose = 0;
		
  while ((ch = getopt(argc, argv, "vl:")) != -1)
    {
      switch (ch)
	{
	case 'l':
	  logFile = optarg;	    
	  break;

	case 'v':
	  verbose = 1;
	  break;

	case '?':
	break;
	
	} /* switch */
    }

  argc -= optind;
  argv += optind;


  // open log file
  FILE *fdLog = NULL;
  if(logFile != NULL)
    fdLog = setLogData(logFile);

  // load user settings in inertial sensor
  getUserInputs(argv[0], &portNumber, deviceName,  &outputMode, &outputSettings);	

  // Open and initialize serial port
#ifdef WIN32
  if (mtcomm.openPort(portNumber) != MTRV_OK)
    {
      printf("Cannot open COM port %d\n", portNumber);
#else
      if (mtcomm.openPort(deviceName) != MTRV_OK)
	{
	  printf("Cannot open COM port %s\n", deviceName);
#endif
	  return MTRV_INPUTCANNOTBEOPENED;
	}	

      if(doMtSettings(mtcomm, outputMode, &outputSettings, &numDevices) == false)
	return MTRV_UNEXPECTEDMSG;
       
      // output format logged into log file if needed
      if(verbose == 1 || logFile != NULL)
	{
	  memset(msg, 0, 50);
	  sprintf(msg,"MTI Calibrated sensor data - LAAS/CNRS 2006\n");
	  logTrame(fdLog, verbose, msg);
	  memset(msg, 0, 50);
	  sprintf(msg,"ACCX ACCY ACCZ : unity m/s2 \nGYRX GYRY GYRZ : unity rad/s\nMAGNX MAGNY MAGNZ : arbitrary units normalized to earth field strength\nEulerX EulerY EulerZ : unity degree\n");			   
	  logTrame(fdLog, verbose, msg);
	}
	
      while(1)
	{
	  if(mtcomm.readDataMessage(data, datalen) == MTRV_OK)
	    {
	      // get real time clock
	      printHorodatage(msgHorodatage);

	      mtcomm.getValue(VALUE_SAMPLECNT, samplecounter, data, BID_MASTER);      		 
	 				
	      if ((outputMode & OUTPUTMODE_CALIB) != 0)
		{
		  // Output Calibrated data
		  mtcomm.getValue(VALUE_CALIB_ACC, fdata, data, BID_MT);	
		      
		  if(verbose == 1 || logFile != NULL)
		    {
		      memset(msg, 0, 50);
		      sprintf(msg,"ACC %s %g %g %g", msgHorodatage, fdata[0], fdata[1], fdata[2]);			   
		      logTrame(fdLog, verbose, msg);
		    }
					
		  mtcomm.getValue(VALUE_CALIB_GYR, fdata, data, BID_MT);		 

		  if(verbose == 1 || logFile != NULL)
		    {
		      memset(msg, 0, 50);
		      sprintf(msg,"GYR %s %g %g %g", msgHorodatage, fdata[0], fdata[1], fdata[2]);
		      logTrame(fdLog, verbose, msg);
		    }
					 
		  mtcomm.getValue(VALUE_CALIB_MAG, fdata, data, BID_MT);		

		  if(verbose == 1 || logFile != NULL)
		    {
		      memset(msg, 0, 50);
		      sprintf(msg,"MAGN %s %g %g %g", msgHorodatage, fdata[0], fdata[1], fdata[2]);
		      logTrame(fdLog, verbose, msg);
		    }
		}//endif

	      if ((outputMode & OUTPUTMODE_ORIENT) != 0)
		{
		  switch(outputSettings & OUTPUTSETTINGS_ORIENTMODE_MASK)
		    {
		    case OUTPUTSETTINGS_ORIENTMODE_QUATERNION:
		      // Output: quaternion
		      mtcomm.getValue(VALUE_ORIENT_QUAT, fdata, data, BID_MT);
		      printf("%6.3f\t%6.3f\t%6.3f\t%6.3f\n",
			     fdata[0],
			     fdata[1], 
			     fdata[2], 
			     fdata[3]); 
		      break;
		    case OUTPUTSETTINGS_ORIENTMODE_EULER:
		      // Output: Euler
		      printHorodatage(msgHorodatage);
		      mtcomm.getValue(VALUE_ORIENT_EULER, fdata, data, BID_MT);		

		      if(verbose == 1 || logFile != NULL)
			{
			  memset(msg, 0, 50);
			  sprintf(msg,"Euler %s %g %g %g", msgHorodatage, fdata[0], fdata[1], fdata[2]);
			  logTrame(fdLog, verbose, msg);
			}			  

		      break;
		    case OUTPUTSETTINGS_ORIENTMODE_MATRIX:
		      // Output: Cosine Matrix
		      mtcomm.getValue(VALUE_ORIENT_MATRIX, fdata, data, BID_MT);
		      printf("%6.3f\t%6.3f\t%6.3f\n",fdata[0], 
			     fdata[1], 
			     fdata[2]);
		      printf("%6.3f\t%6.3f\t%6.3f\n",fdata[3],
			     fdata[4], 
			     fdata[5]);
		      printf("%6.3f\t%6.3f\t%6.3f\n",fdata[6], 
			     fdata[7], 
			     fdata[8]);
		      break;
		    default:
		      ;
		    }// end switch
		} // endif	
	    } //endif check read data
	  else // display error on read buffer
	    {
	      if(verbose == 1 || logFile != NULL)
		{
		  memset(msg, 0, 50);	
		  sprintf(msg, "failed to read message, code (%d)\n", mtcomm.getLastRetVal());
		  logTrame(fdLog, verbose, msg);
		}
	      else
		fprintf(stderr, "MTI failed to read message, code (%d)\n", mtcomm.getLastRetVal());
	    }
	}// end while

      // if data logged then, close fd

      if(fdLog != NULL)
	{	
	  fclose(fdLog);
	}

      // When done, close the serial port
      mtcomm.close();

      return MTRV_OK;
    }


